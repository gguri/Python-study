
# 괄호 매칭
#
# (, ), {, }, <, >, [, ] 의 여덟개의 문자로만 구성된 문자열이 입력으로 주어진다고 해 봅시다.
#
# 이때, 이 문자열이 유효한지를 확인하는 함수를 작성 해 보세요.
#
# 열린 괄호들이 닫히는 순서가 올바르게 되어 있는 경우에 그 문자열을 유효하다고 합니다.
#
# 즉, ({()}) 나 []<>{} 등은 유효한 문자열이며, )( <] <(>) 등은 유효하지 않은 문자열입니다.
#
#  1.“열린 순서대로 닫히는” 것을 어떻게 구현 할 수 있을지 고민 해 보세요.


# 한번 열린 괄호는 반드시 닫혀야만 한다
# 먼저 열린 괄호는 다른 괄호가 닫히기 전에 먼저 닫혀야 한다.
def isParenthesisValid(st):
	stack = []
	# pdic = {"{":"}", "[":"]", "(":")", "<":">"}
	pdic = {"}": "{", "]": "[", ")": "(", ">": "<"}
	# 닫힌 애를 알려줬을때 열린애를 알아야 하니 pdic은 이 순서로 사용해야한다
	pOpens = {"{", "[", "(", "<"}

	for ch in st:
		if ch in pOpens:
			stack.append(ch)
		else:
			# stack list가 0인 경우도 있을 수 있기 때문에 len(stack)
			# 그냥 할 경우 out of range
			if len(stack) != 0 and stack[-1] == pdic[ch]:
				stack.pop()
			else:
				return False
	# 다했는데 스택에 뭔가 남아 있으면 틀린것
	if len(stack) != 0:
		return False

	return True


def main():
	examples = ["({()})", "[]<>{}", ")(" "<]", "<(>)"]
	for example in examples:
		print(example, isParenthesisValid(example))


if __name__ == "__main__":
	main()

	# )( 케이스 : 항상 ( : 열린게 먼저 나와야 한다.
	# < ] 열린애와 닫힌애의 갯수가 다르다
	# 열리고열리고 닫히고닫히고 => 순서

	# "열린 순서대로 닫히는것" => 스택을 써야된다는 감이 와야함

	# ({( / )})
	# 열린 애들은 어딘가에 다 저장이 되어야 한다.
	# 닫힌 애들이 나오면 가장 마지막에 열린애를 봐야되는데
	# 마지막에 열린애를 내보내야됨. LIFO() - 스택